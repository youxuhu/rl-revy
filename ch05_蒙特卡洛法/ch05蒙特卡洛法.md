# 5 蒙特卡洛方法
## 5.1 蒙特卡洛方法的基础知识
### 5.1.1 骰子的点数之和
两个骰子点数之和
```python
ps = {2:1/36, 3:2/36, 4:3/36, 5:4/36, 6:5/36, 7:6/36, 8:5/36, 9:4/36, 10:3/36, 11:2/36, 12:1/36}
V = 0
for x, p in ps.items():
    V += x*p
print(V)
```
上面的代码根据输入的概率分布求期望值。只要知道概率分布就可以向上面那样计算期望值。

### 5.1.2 分布模型和样本模型
将一个表示概率分布的模型称为<strong>分布模型</strong>.
样本模型是只需要采样的模型。分布模型和样本模型的区别在于，分布模型需要知道概率分布，而样本模型只需要采样。

在样本模型中不需要显示的提供概率分布，唯一的要求就是可以进行采样。
下面来实际的实现采样模型。本次使用的是样本模型。
```python
import numpy as np

def sample(dices=2):
    x = 0
    for _ in range(dices):
        x += np.random.choice([1, 2, 3, 4, 5, 6]) # 以相同的概率在例表选取一个
    return x

if __name__ == "__main__":
    for _ in range(10):
        print(sample())
```
### 5.1.3 蒙特卡洛方法的实现
下面编写一个使用蒙特卡洛法求期望值的代码
```python
if __name__ == "__main__":
    trial = 1000
    samples = []
    for _ in range(trial):
        s = sample()
        samples.append(s)

    V = sum(samples) / len(samples)
    print(f"V = {V}")
```

使用增量法来计算，计算会更加的高效
```python
if __name__ == "__main__":
    trial = 1000
    V, n = 0, 0
    for _ in range(trial):
        s = sample()
        n += 1
        V += (s-V)/n
        print(f"Trial: {n}, Sample: {s}, Average: {V:.2f}")
```
上面的代码在运行的过程中，会在每次获得样本数据时计算平均值。结果显示，随着样本数据的增加，平均值逐渐接近正确答案7。

## 5.2 使用蒙特卡洛方法评估策略

我们可以用智能代理在实际行动中获得的经验来估计价值函数。
### 5.2.1 使用蒙特卡洛方法计算价值函数

蒙特卡洛方法只能使用在回合制任务中。由于连续性任务没有“结束”，因此收益的样本数据无法确定。

<font color=orange>具体计算方式见书p126</font>


### 5.2.2 求所有状态的价值函数
在下面的情况中
A->B->C->end
<font color = orange>$G_A=R_0+\gamma R_1+\gamma^2 R_2$</font>
在这个过程中经过了B
<font color = orange>$G_B=R_1+\gamma R_2$</font>
同理我们可以得到C的收益
<font color = orange>$G_C = R_2$</font>

通过这样的计算我们在一次实验中就可以得到3个状态的收益。

### 5.2.3 蒙特卡洛方法的高效实现

<font color = orange>$
G_A = R_0 + \gamma R_1 + \gamma^2 R_2
$G_B = R1 + \gamma R_2$
$G_C = R_2
$
</font>
这些式子可以优化为


$
G_A = R_0 + \gamma G_B
G_B = R_1 + \gamma G_C
G_C = R_2
$
